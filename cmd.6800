volatile:
    防止编译器优化变量，缓存到寄存器；
    阻止编译器调整操作volatile变量的指令顺序；但是无法阻止cpu动态调度换序
-----------------------------------------
用户线程， 内核线程
    1:1 
    m:1
    m:n
-----------------------------------------
gcc hello.c
-----------------------------------------
preprocess
    cpp hello.c >hello.i
    gcc -E hello.c -o hello.i
-----------------------------------------
compile
    gcc -S hello.i -o hello.s
    gcc -S hello.c -o hello.s
-----------------------------------------
as
    as hello.s -o hello.o
    gcc -c hello.s -o hello.o
    gcc -c hello.c -o hello.o
-----------------------------------------
linker
    ld 
    符号决议
    内存分配
    重定位
-----------------------------------------
COFF 
    PE-COFF (windows)
    ELF (linux)
    ----------- 
    ELF file type
        relocate file: .o
        executale file: ls
        shared object file: .so
        core dump file: linux core-dump file 
    -----------
    file bash
    file hello.o
    file /lib/i386-linux-gnu/libz.so.1.2.8
    -----------
-----------------------------------------
executale/object 
    file formt
        FILE HEADER
        .text section
        .data section
        .bss  section
    -----------
    分为text section和 data section的优点：
        对text section的保护
        提高cpu cache hit ratio
        对text section的共享， 减少内存
-----------------------------------------
objdump -h object.file 
objdump -x -d -s object.file 
    ELF HEADER 
    .text 
    .data
    .bss
    .rodata
    .comment
    .debug
    .dynamic
    .hash
    .line
    .note
    .strtab
    .symtab
    .shstrtab
    .plt
    .got
    .init
    .fini
size object.file 
-----------------------------------------
objcopy
-----------------------------------------
__attrbute__((section("foo"))) int global = 42;
-----------------------------------------
ELF-HEADER
    readelf -h elf.file
    /usr/include/elf.h 
        Elf32_Ehdr
        Elf64_Ehdr
            e_ident: elf-magic
            e_type: 
                et_rel
                et_exec
                ec_dyn
            e_machine:
-----------------------------------------
ELF-SECTION-HEADER_TABLE
    readelf -s elf.file
    /usr/include/elf.h 
        Elf32_Shdr 
        Elf64_Shdr
            sh_type:
                SHT_NULL
                SHT_PROGBIT
                SHT_SYMTAB
                ...
            sh_flag:
                SHF_WRITE
                SHF_ALLOC
                SHF_EXECINSTR
            sh_name:
                .bss
                .comment
                .data 
                ...
            sh_link:
            sh_info:
-----------------------------------------
ELF-RELOCATION-TABLE
    .rel.text
    SHT_REL
ELF-STRING-TABLE
    .strtab, .shstrtab
-----------------------------------------
symbol name
symbol value
symbol table

nm elf.file
-----------------------------------------
ELF-SYM-TABLE
    readelf -s elf.file
    .symtab
    Elf32_Sym
    Elf64_Sym 
        st_name
        st_value
            offset
            SHN_COMMON
            virtual-addr in executale elf.file
        st_shndx
            section-indx
            special-const
                SHN_ABS
                SHN_COMMON
                SHN_UNDEF
        st_info
            type
                STB_LOCAL
                STB_GLOBAL
                STB_WEAK
            bind
                STT_NOTYPE
                STT_OBJECT
                STT_FUNC
                STT_SECTION
                STT_FILE
    -----------
    special-sym
        __executable_start
        __etext, _etext, etext
        _data,data
        _end, end,

        all are virtual-add 
-----------------------------------------
symtab collistion
    old
        _foo unix
        _foo_ wodows
    foo : gcc 
    -----------
    c++ name decoration
        _Z4funci
        _ZN1CfuncEi
        _ZN1C2C2funcEi
    c++filt symbolName
-----------------------------------------
c++ and c 
    -----------
    extern "C" 
    {
        int func(int);
        int var;
    }

    or 

    extern int func(int);
    extern int var;
    -----------
    #ifdef __cplusplus
    extern "C"
    #endif
    {
        void *memset (void *, int, size_t);
    #ifdef __cplusplus
    }
    #endif
-----------------------------------------
strong symbol
    function define
    inited-global define 
weak symbol
    not inited-global define 
modify strong-2-weak
__attrbute__((weak)) weak2 = 2
-----------
rule:
    strong symbol not allowed multi define 
    select strong symbol from strong/weak symbol
    select max-storage symbol from full weak symbols
-----------------------------------------
strong reference
    symbol-define not found, link error
weak reference
    symbol-define not found, link ok
-----------
__attrbute__((weakref)) void foo();
int main()
{
    if (foo) foo();
}
-----------------------------------------
weak-symbol and weak-ref useage:
    define weak symbol in lib, in case user-define strong-symbol
    define extended module by weak-ref
-----------------------------------------
g++ -g
    debug-section 
        DWARF
        CodeView 
-----------------------------------------
strip
-----------------------------------------
gcc -v
-lpthread
    old enougle 
-pthread
    new, -D_REENTRANT -lpthread
-----------------------------------------
gcc pthread.c -o pt 
gcc pthread.c -pthread -o pt 
-----------
gcc weak_ref.c -o weak_ref 
gcc weak_ref.c foo.c -o weak_ref
-----------------------------------------
two-pass link 
    space and addr alloc 
    symbol resolve and re-addr
----------------------------------------
ld a.o b.o -e main -o ab
-----------------------------------------
